
import sys
import random
import numpy as np
from queue import Queue, PriorityQueue

# ËæìÂá∫Ë∞ÉËØïÊó•Âøó
import logging
logger = logging.getLogger()
# Êñá‰ª∂‰øùÂ≠ò
file_handler = logging.FileHandler("main.log", "w", encoding="utf-8")
logger.addHandler(file_handler)
# Ê†ºÂºè
# formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
# file_handler.setFormatter(formatter)
# Êó•ÂøóÁ∫ßÂà´
logger.setLevel(logging.DEBUG)

# Ë∞ÉËØïÊñ≠ÁÇπ
import time
# time.sleep(20)

# Â∏∏ÈáèÂèÇÊï∞
n = 200
robot_num = 10
berth_num = 10
N = 210


# Êé•ÂèóËæìÂÖ•ÁöÑÂÆû‰ΩìÁ±ªÈÉ®ÂàÜ
# Êú∫Âô®‰∫∫
class Robot:
    def __init__(self, id, startX=0, startY=0, goods=0, status=0, mbx=0, mby=0):
        self.id = id
        self.x = startX
        self.y = startY
        self.goods = goods
        self.status = status
        self.mbx = mbx
        self.mby = mby

        self.aim_type = "" # ÁõÆÊ†á‰∏∫Á©∫""ÔºåË¥ßÁâ©"good", Ê≥ä‰Ωç"berth"
        self.direction_list = []


robot = [Robot(i) for i in range(robot_num + 10)]


# Ê≥ä‰Ωç
class Berth:
    def __init__(self, id, x=0, y=0, transport_time=0, loading_speed=0):
        self.id = id
        self.x = x
        self.y = y
        self.transport_time = transport_time
        self.loading_speed = loading_speed
        self.boat_id = -1 # ÂÅúÈù†ÁöÑËΩÆËàπidÔºåÊ≤°ÊúâÂÅúÈù†Âàô‰∏∫-1
        self.good_queue = Queue() #  Ë¥ßÁâ©ÈòüÂàó
        self.loaded_good_num = 0 #  Â∑≤ÁªèÂæÄÂΩìÂâçËàπ‰∏äË£ÖËΩΩÁöÑË¥ßÁâ©Êï∞Èáè

berth = [Berth(i) for i in range(berth_num + 10)]


# ËΩÆËàπ
class Boat:
    def __init__(self, id, num=0, pos=0, status=0):
        self.id = id
        self.num = num
        self.pos = pos
        self.status = status


boat = [Boat(i) for i in range(10)]

# Âú∞Âõæ‰∏≠ÁöÑÁªìÁÇπ
RIGHT = 0
LEFT = 1
UP = 2
DOWN = 3
class Node:
    def __init__(self, x, y, type):
        self.x, self.y = x, y
        # self.type = "ocean" # Êµ∑Ê¥ãlandÔºåÈôÜÂú∞landÔºåÊ≥ä‰ΩçberthÔºåÈöúÁ¢çbarrier
        self.type = type # Êµ∑Ê¥ã*ÔºåÈôÜÂú∞.ÔºåÊ≥ä‰ΩçBÔºåÈöúÁ¢ç#
        if self.type == 'A':
            self.type = '.'
        # ÂêéÁª≠Áî®‰∫éÊú∫Âô®‰∫∫ÂØªË∑ØÔºåÂè™ÂØπÈôÜÂú∞ÊúâÊïà
        self.berth_visited_list = [False for _ in range(berth_num)] # ÊòØÂê¶ÊúâÂà∞ÂêÑ‰∏™Ê≥ä‰ΩçÁöÑË∑ØÂæÑ
        self.berth_best_direction_list = [RIGHT for _ in range(berth_num)] # Âà∞ËØ•Ê≥ä‰ΩçË∑ØÂæÑÁöÑÊúÄÁü≠ÊñπÂêë


class Map:
    def __init__(self):
        self.node_matrix = []
    
    def init_map(self, ch):
        for x in range(n):
            tmp_node_list = []
            for y in range(n):
                item = ch[x][0][y]
                tmp_node_list.append(Node(x, y, item))
            self.node_matrix.append(tmp_node_list)
    
    def get_neighbor_list(self, x, y):
        neighbor_list = []
        if x > 0:
            neighbor_list.append([[x-1, y], DOWN])
        if x < n-1:
            neighbor_list.append([[x+1, y], UP])
        if y > 0:
            neighbor_list.append([[x, y-1], RIGHT])
        if y < n-1:
            neighbor_list.append([[x, y+1], LEFT])
        return neighbor_list

    # ‰ªéÂõ∫ÂÆöÊ≥ä‰ΩçÂºÄÂßãÁöÑbfs
    def bfs_berth(self, berth_id, berth_x, berth_y):
        # ÈòüÂàóÂàùÂßãÂåñ
        q = Queue()
        # ÂØπ‰∏ä‰∏ãÂ∑¶Âè≥Ëæπ‰∏äÂõõÂë®ÁöÑ16‰∏™ÁÇπÂàùÂßãÂåñÔºåÂè™ÂØπÈôÜÂú∞ÁÇπ.ËÆæÁΩÆ
        if berth_x > 0:
            for y in range(berth_y, berth_y+4):
                node = self.node_matrix[berth_x-1][y]
                if node.type == '.':
                    q.put((node.x, node.y))
                    node.berth_visited_list[berth_id] = True
                    node.berth_best_direction_list[berth_id] = DOWN
                    logger.info(f"{node.x}, {node.y}, DOWN")
        if berth_x+4 < n:
            for y in range(berth_y, berth_y+4):
                node = self.node_matrix[berth_x+4][y]
                if node.type == '.':
                    q.put((node.x, node.y, ))
                    node.berth_visited_list[berth_id] = True
                    node.berth_best_direction_list[berth_id] = UP
                    logger.info(f"{node.x}, {node.y}, UP")
        if berth_y > 0:
            for x in range(berth_x, berth_x+4):
                node = self.node_matrix[x][berth_y-1]
                if node.type == '.':
                    q.put((node.x, node.y))
                    node.berth_visited_list[berth_id] = True
                    node.berth_best_direction_list[berth_id] = RIGHT
                    logger.info(f"{node.x}, {node.y}, RIGHT")
        if berth_y+4 < n:
            for x in range(berth_x, berth_x+4):
                node = self.node_matrix[x][berth_y+4]
                if node.type == '.':
                    q.put((node.x, node.y))
                    node.berth_visited_list[berth_id] = True
                    node.berth_best_direction_list[berth_id] = LEFT
                    logger.info(f"{node.x}, {node.y}, LEFT")
        
        # Ê∑±Â∫¶‰ºòÂÖàÈÅçÂéÜ
        while not q.empty():
            x, y = q.get()
            node = self.node_matrix[x][y]
            for (neighbor_x, neighbor_y), direction in self.get_neighbor_list(x, y):
                neighbor_node = self.node_matrix[neighbor_x][neighbor_y]
                if neighbor_node.type == '.' and neighbor_node.berth_visited_list[berth_id]==False:
                    # ÂØπÊ≤°ÊúâËÆøÈóÆËøáÁöÑÈôÜÂú∞ÁÇπËÆæÁΩÆ
                    neighbor_node.berth_visited_list[berth_id] = True
                    neighbor_node.berth_best_direction_list[berth_id] = direction
                    q.put((neighbor_x, neighbor_y))
        
    # Êú∫Âô®‰∫∫‰ΩçÁΩÆ‰∏éÁõÆÊ†á‰ΩçÁΩÆÁöÑA*ÁÆóÊ≥ï
    def heuristic_distance(self, start, aim):
        return abs(start[0] - aim[0]) + abs(start[1] - aim[1])
    
    # Êú∫Âô®‰∫∫‰ΩçÁΩÆ‰∏éÁõÆÊ†á‰ΩçÁΩÆÁöÑA*ÁÆóÊ≥ï
    def pos_A_star(self, start, aim):
        logger.info(f"A*: ({start})->({aim})")
        q = PriorityQueue()
        q.put((0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while not q.empty():
            current= q.get()[1]
            # logger.debug(f"current: {current}")

            if current == aim:
                break
            
            neighbor_list = self.get_neighbor_list(current[0], current[1])
            # logger.debug(f"neighbor_list: {neighbor_list}")

            for neighbor, direction in neighbor_list:
                node = self.node_matrix[neighbor[0]][neighbor[1]]
                if node.type == '.':
                    neighbor = tuple(neighbor) # ËΩ¨Âåñ‰∏∫ÂÖÉÁªÑÊâçÂèØÁî®
                    # logger.debug(f"neighbor: {neighbor}")
                    new_cost = cost_so_far[current] + 1 # ÁΩëÊ†ºÁ±ªÂûãÊï∞ÊçÆ‰ª£‰ª∑ÈÉΩÊòØ1
                    # logger.debug(f"new_cost: {new_cost}")
                    if (not neighbor in cost_so_far.keys()) or (new_cost < cost_so_far[neighbor]):
                        cost_so_far[neighbor] = new_cost
                        priority = new_cost + self.heuristic_distance(neighbor, aim)
                        # logger.debug(f"priority: {priority}")
                        q.put((priority, neighbor))
                        came_from[neighbor] = current
            
        logger.debug(f"came_from : {came_from}")

        # ÂõûÊ∫Ø
        tmp_pos = aim
        pos_list = []
        direction_list = []
        dirction_dict = {
            (0, 1) : RIGHT,
            (0, -1) : LEFT,
            (1, 0) : DOWN,
            (-1, 0) : UP,
        }
        while not tmp_pos == start:
            pre_pos = came_from[tmp_pos]
            pos_list.append(pre_pos)
            dirction = dirction_dict[(tmp_pos[0]-pre_pos[0], tmp_pos[1]-pre_pos[1])]
            direction_list.append(dirction)
            tmp_pos = pre_pos
        logger.info(f"pos_list : {pos_list}")
        logger.info(f"direction_list : {direction_list}")
        
        # ËæìÂá∫Ë∑ØÂæÑ
        pos_direction_dict = dict(zip(pos_list, direction_list))
        for i in range(n):
            row = ""
            for j in range(n):
                node = m.node_matrix[i][j]
                pos = (node.x, node.y)
                if pos == aim:
                    row += "üëë" 
                elif pos in pos_direction_dict.keys() and node.type == '.':
                        direction = pos_direction_dict[pos]
                        if direction == UP:
                            row += '‚Üë'
                        elif direction == DOWN:
                            row += '‚Üì'
                        elif direction == LEFT:
                            row += '‚Üê'
                        else:
                            row += '‚Üí'
                else:
                    row += node.type
            logger.info(row)
        
        return pos_direction_dict


m = Map()

money = 0
boat_capacity = 0
id = 0
ch = []
gds = [[0 for _ in range(N)] for _ in range(N)] # Ë¥ßÁâ©ÂàóË°®
gd0_pos = [-1, -1] # Á¨¨‰∏Ä‰∏™Âá∫Áé∞ÁöÑË¥ßÁâ©ÂùêÊ†áÔºå‰øùÂ≠ò‰∏∫ÂàóË°®ÔºåÂáΩÊï∞ÊâçËÉΩÊõ¥ÊîπÂÖ∂ÂÜÖÈÉ®ÂÖÉÁ¥†
gds_pos_statck = [] # ‰ΩøÁî®ÂàóË°®ÂÆûÁé∞ÁöÑÊ†à

# Êé•ÂèóÂàùÂßãËæìÂÖ•
def Init():
    # Âú∞Âõæ
    for i in range(0, n):
        line = input()
        ch.append([c for c in line.split(sep=" ")]) # 
    # Ê≥ä‰Ωç
    for i in range(berth_num):
        line = input()
        berth_list = [int(c) for c in line.split(sep=" ")]
        id = berth_list[0]
        berth[id].x = berth_list[1]
        berth[id].y = berth_list[2]
        berth[id].transport_time = berth_list[3]
        berth[id].loading_speed = berth_list[4]
    global boat_capacity # ÂÖ®Â±ÄÂèòÈáèÁöÑÂ£∞Êòé
    boat_capacity = int(input())
    # TODO: ËÆ°ÁÆóÊâÄÊúâÈôÜÂú∞ÁÇπÂà∞Ê≥ä‰ΩçÁöÑÊúÄÁü≠Ë∑ØÂæÑ
    m.init_map(ch)
    logging.info("bfs berth 0")
    m.bfs_berth(0, berth[0].x, berth[0].y)
    # OKÁ°ÆÂÆö
    okk = input()
    print("OK")
    sys.stdout.flush()

# Êé•ÂèóÂçïÂ∏ßËæìÂÖ•
def Input():
    global id, money
    id, money = map(int, input().split(" ")) # frame_idÔºåÊî∂Áõä
    # Êñ∞Â¢ûÁâ©ÂìÅÈÉ®ÂàÜ
    num = int(input())
    for i in range(num):
        x, y, val = map(int, input().split())
        gds[x][y] = val
        gds_pos_statck.append((x, y))
        if gd0_pos[0] == -1:
            # ‰øùÂ≠òÁ¨¨‰∏Ä‰∏™Ë¥ßÁâ©
            gd0_pos[0] = x
            gd0_pos[1] = y
    # ÊâÄÊúâÊú∫Âô®‰∫∫ÔºåÊòØÂê¶Â∏¶Ë¥ß„ÄÅÂùêÊ†áx„ÄÅÂùêÊ†áy„ÄÅÊòØÂê¶Á¢∞ÊíûÂêéÊÅ¢Â§ç
    for i in range(robot_num):
        robot[i].goods, robot[i].x, robot[i].y, robot[i].status = map(int, input().split())
    # ÊâÄÊúâËΩÆËàπÔºåÁä∂ÊÄÅ„ÄÅÁõÆÊ†áÊ≥ä‰Ωç
    for i in range(5):
        boat[i].status, boat[i].pos = map(int, input().split())
    okk = input()

flag = False # Á¨¨0‰∏™Êú∫Âô®‰∫∫ÊääÁ¨¨0‰∏™Ë¥ßÁâ©ËøêËææÁ¨¨0‰∏™Ê≥ä‰ΩçÁöÑÊ†áËØÜÁ¨¶

# ÂçïÂ∏ßËæìÂá∫
def Output():
    logger.debug(f"{id}")
    if id==1:
        # ÂàùÂßãÔºö0Âè∑ËΩÆËàπÂà∞Ëææ0Âè∑Ê≥ä‰Ωç
        print(f"ship 0 0")
        logger.debug(f"transport_time: {berth[0].transport_time}") # Ê≥ä‰ΩçÂà∞ËôöÊãüÁÇπÁöÑÊó∂Èó¥
        for i in ch:
            logger.info(f"{i}")
            # ÊâìÂç∞ÊâÄÊúâÁÇπÂà∞0Âè∑Ê≥ä‰ΩçÁöÑÊúÄÁü≠Ë∑ØÂæÑ
        for i in range(n):
            row = ""
            for j in range(n):
                node = m.node_matrix[i][j]
                if node.type == '.':
                    direction = node.berth_best_direction_list[0]
                    if direction == UP:
                        row += '‚Üë'
                    elif direction == DOWN:
                        row += '‚Üì'
                    elif direction == LEFT:
                        row += '‚Üê'
                    else:
                        row += '‚Üí'
                else:
                    row += node.type
            logger.info(row)

    # TODO: ÊâÄÊúâÊú∫Âô®‰∫∫Ë∞ÉÂ∫¶
    for i in range(3):
        robot_i = robot[i]
        if robot_i.aim_type == "" and (not len(gds_pos_statck)==0):
            # Ê≤°ÊúâÂ∏¶Ë¥ßÔºåËßÑÂàíÂà∞ÊúÄÊñ∞ÁöÑÂèØËææË¥ßÁâ©ÁöÑË∑ØÂæÑ
            logger.info(f"robot({i})ËßÑÂàíÂºÄÂßã")
            new_good = gds_pos_statck.pop()
            good_node = m.node_matrix[new_good[0]][new_good[1]]
            while  not good_node.berth_visited_list[0]:
                logger.debug(f"{new_good} unavailable!")
                new_good = gds_pos_statck.pop()
                good_node = m.node_matrix[new_good[0]][new_good[1]] 
            logger.debug(f"{new_good} available!")
            pos_direction_dict = m.pos_A_star((robot_i.x, robot_i.y), new_good) # A*‰∏çÂÜçÊòØÊñπÂêëÂêëÈáè‰∫ÜÔºåËé∑ÂæóË∑ØÂæÑÁî®Â≠óÂÖ∏Â≠òÂÇ®ÔºåÊñπ‰æøÂêéÁª≠ÁöÑÁ¢∞ÊíûÂêéÁöÑË∑ØÂæÑÊÅ¢Â§ç
            logger.info(f"robot({i})ËßÑÂàíÁªìÊùü")
            robot_i.aim_type = "good"
            # robot_i.direction_list = direction_list
            robot_i.aim_pos = new_good 
            robot_i.pos_direction_dict = pos_direction_dict
        elif robot_i.aim_type == "good":
            # ÁßªÂä®Âà∞Ë¥ßÁâ©ÁöÑ‰ΩçÁΩÆ
            robot_pos = (robot_i.x, robot_i.y)
            logger.debug(f"robot({i}) : ({robot_pos})->{robot_i.aim_pos}")
            # if len(robot_i.aim_pos) > 0:
            if not robot_i.aim_pos == robot_pos:
                # direction = robot_i.direction_list.pop()
                direction = robot_i.pos_direction_dict[robot_pos]
                print(f"move {i} {direction}")
            else:
                print(f"get {i}")
                logger.info(f"robot({i})Ë¥ßÁâ©getÊàêÂäü")
                robot_i.aim_type = "berth"
        elif robot_i.aim_type == "berth":
            # Â∏¶Ë¥ß‰∫ÜÔºåÁßªÂä®Âà∞0Âè∑Ê≥ä‰Ωç
            node = m.node_matrix[robot_i.x][robot_i.y]
            direction = node.berth_best_direction_list[0]
            logger.debug(f"robot({i}) : {(robot_i.x, robot_i.y)}->{(berth[0].x, berth[0].y)}")
            if node.type == '.':
                print(f"move {i} {direction}")
            else:
                # Âà∞‰∫ÜÊ≥ä‰ΩçÂ∞±Êîæ‰∏ã
                print(f"pull {i}")
                logger.info(f"robot({i})Ë¥ßÁâ©pullÊàêÂäü")
                robot_i.aim_type = ""
                berth[0].good_queue.put(0) # Èöè‰æøÊîæ‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂè™ÊòØÂç†‰ΩçÁΩÆÁî®ÁöÑ
    
    # TODO: ÊâÄÊúâËΩÆËàπË∞ÉÂ∫¶
    # for i in range(5):
    for i in range(1):
        boat_i = boat[i]
        if (boat_i.status == 1) and (not boat_i.pos == -1):
            # ËΩÆËàπÂà∞ËææÊ≥ä‰Ωç
            logger.debug(f"boat({i}) reach berth({boat_i.pos})")
            berth[boat_i.pos].boat_id = boat_i.id

    # TODO: ÊâÄÊúâÊ≥ä‰ΩçË∞ÉÂ∫¶
    # for i in range(berth_num):
    for i in range(1):
        berth_i = berth[i]
        if not berth_i.boat_id == -1:
            # ÂΩìÂâçÊ≥ä‰ΩçÊúâËàπÂàôÂºÄÂßãË£ÖË¥ß
            for j in range(berth_i.loading_speed):
                berth_i.good_queue.get() # ÂèñÂá∫‰∏Ä‰∏™Ë¥ß
                berth_i.loaded_good_num += 1
                logger.debug(f"berth({i}) : {berth_i.loaded_good_num }/{boat_capacity}")
                # if berth_i.loaded_good_num == boat_capacity:
                if berth_i.loaded_good_num == 3: # ÊµãËØï‰∏Ä‰∏ãË£ÖÊª°3‰∏™Ë¥ßÂ∞±Ëµ∞
                    # Ë¥ßË£ÖÊª°‰∫ÜÔºåËΩÆËàπÂá∫Âèë
                    print(f"go {berth_i.boat_id}")
                    logger.debug(f"berth({i}) full, boat({berth_i.boat_id}) go!")
                    berth_i.boat_id = -1
                    berth_i.loaded_good_num = 0
                    break

    # TODO: 0Âè∑ËΩÆËàπÁ≠âÂà∞ÊúÄÂêéÊâçËµ∞ÂéãÁùÄÂ∏ßÊï∞
    max_frame = 15000
    if id == max_frame - berth[0].transport_time:
        print("go 0") # ÊúâÊ†áËÆ∞‰∫ÜÔºåË£Ö‰∏äË¥ßÁâ©ÂêéÂºÄÂæÄËôöÊãüÁÇπ
        logger.info(f"ËΩÆËàπÂá∫Âèë")
    return

if __name__ == "__main__":
    Init()
    for zhen in range(1, 15001):
        Input()
        Output()
        for i in range(robot_num):
            # print("move", i, random.randint(0, 3))
            sys.stdout.flush()
        print("OK")

        sys.stdout.flush()
